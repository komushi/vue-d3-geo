<!DOCTYPE html>
<meta charset="utf-8">
<style>

.cell-border {
  fill: none;
  stroke: #ccc;
  pointer-events: all;
  vector-effect: non-scaling-stroke;
}

.cell-center {
  fill: none;
  vector-effect: non-scaling-stroke;
  pointer-events: all;
  stroke: orange;
}

.label {
  font: 11px sans-serif;
}

.label--top {
  text-anchor: middle;
}

.label--right {
  text-anchor: start;
}

.label--bottom {
  text-anchor: middle;
}

.label--left {
  text-anchor: end;
}

</style>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script>

var width = 1400,
    height = 900,
    displayThreshold = 2000;

var randomX = d3.random.normal(width / 2, 80),
    randomY = d3.random.normal(height / 2, 80);

var data = d3.range(200)
    .map(function() { return [randomX(), randomY()]; })
    .filter(function(d) { return 0 <= d[0] && d[0] <= width && 0 <= d[1] && d[1] <= height; });

var zoom = d3.behavior.zoom()
  .scaleExtent([1, 8])
  .on("zoom", zoomed);

var cells = d3.geom.voronoi()
    .clipExtent([[-1, -1], [width + 1, height + 1]])
    (data)
    .map(d3.geom.polygon);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var g = svg.append('g').call(zoom);

var cell = g.append("g")
    .attr("class", "cell")
  .selectAll("g")
    .data(cells)
  .enter().append("g");

cell.append("path")
    .attr("class", "cell-center")
    .attr("d", function(d) { return "M" + d.centroid() + "L" + d.point; });

cell.append("path")
    .attr("class", "cell-border")
    .attr("d", function(d) { return "M" + d.join("L") + "Z"; });

g.append("g")
    .attr("class", "dot")
  .selectAll("circle")
    .data(data)
  .enter().append("circle")
    .attr("transform", function(d) { return "translate(" + d + ")"; })
    .attr("r", 2.5);

g.append("g")
    .attr("class", "label")
  .selectAll("text")
    .data(cells)
  .enter().append("text")
    .each(function(d) {
      // compute the scale threshold for this element. i.e. how big does the scale need to be before I should display
      d.scaleThreshold = Math.sqrt(displayThreshold / d.area());
      d.opacityScale = d3.scale.linear() 
        .domain([d.scaleThreshold, d.scaleThreshold * 1.3])
        .range([0, 1]);
      
    })
    .attr("class", function(d) {
      var centroid = d.centroid(),
          point = d.point,
          angle = Math.round(Math.atan2(centroid[1] - point[1], centroid[0] - point[0]) / Math.PI * 2);
      return "label--" + (d.orient = angle === 0 ? "right"
          : angle === -1 ? "top"
          : angle === 1 ? "bottom"
          : "left");
    })
    .attr('opacity', function(d) {
      if (d.scaleThreshold < 1) {
        return 1;
      }
      return 0;
    })
    .attr("transform", function(d) { return "translate(" + d.point + ")"; })
    .attr("dy", function(d) { return d.orient === "left" || d.orient === "right" ? ".35em" : d.orient === "bottom" ? ".71em" : null; })
    .attr("x", function(d) { return d.orient === "right" ? 6 : d.orient === "left" ? -6 : null; })
    .attr("y", function(d) { return d.orient === "bottom" ? 6 : d.orient === "top" ? -6 : null; })
    .text(function(d, i) { return i * 1000; });


function zoomed() {
  g.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");

  d3.selectAll('circle').attr('transform', function(d) {
    return 'translate(' + d + ')scale(' + (1/d3.event.scale) + ')';
  });

  d3.selectAll('text')
    .attr('transform', function(d) {
      return 'translate(' + d.point + ')scale(' + (1/d3.event.scale) + ')';
    })
    // .attr('opacity', function(d) {
    //   if (d3.event.scale > d.scaleThreshold) {
    //     return d.opacityScale(d3.event.scale);
    //   } 
    //   return 0;
    // });
}

</script>